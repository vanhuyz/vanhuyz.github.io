<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TIL on vanhuyz's notes</title><link>http://example.org/categories/TIL/</link><description>Recent content in TIL on vanhuyz's notes</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 08 Jun 2016 07:25:00 +0000</lastBuildDate><atom:link href="http://example.org/categories/TIL/index.xml" rel="self" type="application/rss+xml"/><item><title>MeCabに人名辞書を追加</title><link>http://example.org/post/add-custom-dict-to-mecab/</link><pubDate>Wed, 08 Jun 2016 07:25:00 +0000</pubDate><guid>http://example.org/post/add-custom-dict-to-mecab/</guid><description>生成された辞書（バイナリ）はどこでも使えますので、辞書生成はMac側で行います。
インストール $ brew install mecab mecab-ipadic 構成 ## /usr/local/Cellar/mecab └── 0.996 ├── AUTHORS ├── COPYING ├── ChangeLog ├── INSTALL_RECEIPT.json ├── NEWS ├── README ├── bin │ ├── mecab │ └── mecab-config ├── include │ └── mecab.h ├── lib │ ├── libmecab.2.dylib │ ├── libmecab.a │ └── libmecab.dylib -&amp;gt; libmecab.2.dylib ├── libexec │ └── mecab │ ├── mecab-cost-train │ ├── mecab-dict-gen │ ├── mecab-dict-index │ ├── mecab-system-eval │ └── mecab-test-gen └── share └── man └── man1 └── mecab.</description></item><item><title>Elasticsearchのbool queryを利用してAND OR NOTを書いてみる</title><link>http://example.org/post/how-to-use-bool-query-in-elasticsearch/</link><pubDate>Mon, 25 Apr 2016 03:25:00 +0000</pubDate><guid>http://example.org/post/how-to-use-bool-query-in-elasticsearch/</guid><description>※ この記事をQiitaにも載せました！
初めてElasticsearchのクエリをビルドしたのでいろいろハマりました。SQLの世界観とちょっと違っていて、なれるまで時間がかかると思います。でも、なれたら複雑な検索条件をSQLより簡単に書けるかも知れません。
では、Elasticsearchの基礎クエリの一つ、Bool Queryを解説してみます。
Bool Queryについて Elasticsearch 2.0からandクエリとorクエリは全部非推奨になり、その代わりにboolクエリの方が推奨されます。Boolクエリは複数のクエリを組み合わせる（つまりAND、OR、NOTで結合）のに使います。
Boolクエリは４種類があります：must、 filter、 should、 must_ notです。
クエリ 説明 must ANDとして使います。小クエリは総合スコアに影響を与えます filter mustと同じくANDです。ただし、スコアは無視されます（総合スコアに影響を与えません should ORとして使えます。 minimum_should_match パラメータで最低マッチする条項の数が指定できます[^n]。 must_ not NOTです。 使用例 AND条件 例えば、SQLはこういうSELECT文があります。
SELECT * FROM users WHERE age &amp;gt;= 25 AND salary &amp;gt;= 500000; Elasticsearchのクエリに書き直すと、
{ &amp;#34;query&amp;#34;: { &amp;#34;bool&amp;#34; : { &amp;#34;must&amp;#34; : [ { &amp;#34;range&amp;#34; : { &amp;#34;age&amp;#34; : { &amp;#34;gte&amp;#34;: 25 } } }, { &amp;#34;range&amp;#34; : { &amp;#34;salary&amp;#34; : { &amp;#34;gte&amp;#34;: 500000 } } } ] } } } になります。今回はmustを使いますが、スコア無視したい場合はfilterを使えばいいのです。</description></item><item><title>メンテナンス本格入門のまとめ</title><link>http://example.org/post/maintenance-introduction/</link><pubDate>Sat, 29 Aug 2015 06:31:00 +0000</pubDate><guid>http://example.org/post/maintenance-introduction/</guid><description>メンテナンスは必要？ メンテナンスなんてない方がよい それでも行う必要があるとき 歴史的かつ技術的な負債 作業難度のトレードオフ メンテナンスの種類 計画メンテナンス 事前に計画し、ユーザー告知を行って作業を行う。これに当たる主だった作業としては
ハードウェアの保留／入れ替え データベースの設定変更 ネットワークの保留 手順：
作業手順作成 事前準備：Sorryサーバーの準備 テスト環境での予行演習 作業実施：作業チェック、問題発生時の対処 確認作業：モニタリング、作業の振り返り 緊急メンテナンス 障害が発生した場合などに原因を解決／追求品ケラバサービス継続が難しい場合などに行う。内容は
障害復旧 障害の現状保存 障害の詳細調査 手順
障害検知 原因調査 メンテナンス判断 作業実施 確認作業 振り返り・ノウハウ化 その他：ユーザーへ告知、補償 メンテナンスの手法 全停止メンテナンス 一部停止メンテナンス 無停止メンテナンス メンテフリーへのアプローチ メンテフリーとはサビースを停止せずメンテナンスを行う。そのためには、設計、構築、運用のすべての段階で「いかにSPOFをなくし、システム停止せずに作業できるか」を考え続ける必要がある。アプローチは様々あるが、弊社に適したものは以下にあげられる。
Webサーバー、アプリケーションサーバー ロードバランサによって複数のサーバーにアクセスを振り分け、２台以上用意する。Apache/Nginx・アプリケーションサーバーの設定変更や再起動といった作業でユーザーに影響があるシステム構成いなっているものは好ましくない
データベース設計： スキーマ変更の頻度高いサービスはMongoDBへ RDBの場合はマスタスレーブ構成やマスタ分割、スキーマ変更のコストを下げる。MySQLの場合はオンラインスキーマ変更がある リリース： ロードバランサ切り離しによるリリース：ロードバランサからアプリケーションサーバーを分離し、１台ずつアプリケーションを入れ替えていく。Jenkinsなどでサーバーに順次デプロイしていくと良い 系切り替えによるリリース：稼働系と待機系の２系統を準備し、ロードバランサでクライアントの向き先を切り替えてリリースする ホットデプロイによる動的リリース：アプリケーションを再起動せずにモジュールを更新する機能。UnicornやPumaなどはこの機能がある（と書いてある） カナリアリリース：一部のユーザーから徐々に新バージョンのアプリケーションを適用していく手法。FacebookやGoogleの大規模サービスはこの方法でデプロイされている 結論 サービスの種類・規模や原因によって様々なパータンがある。いつ起こるのもわからない。そのため、監視ツールを導入や毎日心構えが必要である（エンジニアの辛い道）</description></item><item><title>Fluentd導入してからエラーログを全部Slackに通知する</title><link>http://example.org/post/send-error-log-to-slack-via-fluentd/</link><pubDate>Thu, 21 May 2015 09:24:00 +0000</pubDate><guid>http://example.org/post/send-error-log-to-slack-via-fluentd/</guid><description>やりたいこと サーバーが落ちるときすぐ管理者に通知する
設計イメージ Fluentdで全部のエラーログをまとめてSlackに送信する。
Fluentd導入 Fluentdとは ログ収集ミドルウェアである。Fluentdにインプットされた、すべてのログをJSONに変換し、アウトプットする。
Fluentdのインストール　(Ubuntu 14.04) 事前準備 ntpをインストールする $ sudo apt-get install ntp ファイルディスクリプタの上限を増やす 現在のファイルディスクリプタ数を確認
$ ulimit -n 1024 もし1024なら不十分なので上限を増やす。/etc/security/limits.conf に以下の行を追加する
root soft nofile 65536 root hard nofile 65536 * soft nofile 65536 * hard nofile 65536 編集終わったらマシン再起動
$ sudo reboot もう一度確認
$ ulimit -n 65536 Fluentdのインストール $ curl -L http://toolbelt.treasuredata.com/sh/install-ubuntu-trusty-td-agent2.sh | sh 起動するときFluentd(td-agent)を自動に起動
$ sudo update-rc.d td-agent defaults Slackへ連帯 FluentdのSlackプラグインをインストールする $ sudo /opt/td-agent/embedded/bin/fluent-gem install fluent-plugin-slack SlackのWebhookを登録 https://yourteam.</description></item><item><title>Railsで論理削除を考慮するunique制約のかけ方</title><link>http://example.org/post/how-to-apply-unique-restriction-with-soft-delete-in-rails/</link><pubDate>Fri, 13 Feb 2015 11:15:00 +0000</pubDate><guid>http://example.org/post/how-to-apply-unique-restriction-with-soft-delete-in-rails/</guid><description>使用バージョン Rails 4.2.0 Ruby 2.2.0 MySQL 5.6 論理削除のgem: paranoia 2.1.0 目的 例えばこういうuserモデルがあります
# 20150119070756_create_users.rb class CreateUsers &amp;lt; ActiveRecord::Migration def change create_table :users do |t| t.string :name, :limit =&amp;gt; 20 t.datetime :deleted_at # &amp;lt;- 論理削除 t.timestamps null: false end end end 注意したいのはdeleted_atコラムは削除した日付です。デフォルトだと、
非削除レコードはdeleted_at IS NULL 削除済みレコードはdeleted_at IS NOT NULL 問題: もしnameをunique制約をかけると、削除済みレコードはそのままデータベースに残るので同じnameのレコードを追加することができません。
目的: 非削除レコードの中でnameをunique制約したい。
ネットで調べるとハマる人が少なくないようです。 今回はデータベースレベルとアプリケーションレベルの両方設定します。
作業内容 まずdeleted_atはNULLだとunique複合キーを設定するのも意味ないのでNULLを避けます。
設定ファイルparanoia.rbを作る # config/initializers/paranoia.rb Paranoia.default_sentinel_value = DateTime.new(0) 以上の１行だけで、
非削除レコードはdeleted_at = '0000-01-01 00:00:00' 削除済みレコードはdeleted_at !</description></item><item><title>MySQLで大量のデータを挿入して、SELECTパーフォマンスを比較する</title><link>http://example.org/post/mysql-performance-experiment/</link><pubDate>Tue, 03 Feb 2015 09:57:00 +0000</pubDate><guid>http://example.org/post/mysql-performance-experiment/</guid><description>大量のデータを扱う機会があるため、データが非常に多いときMySQLのパフォーマンスはどうなるかを検討した。
検討するテーブル： 検討したいquery： SELECT * FROM activity_records WHERE date BETWEEN &amp;#39;2014-01-01&amp;#39; AND &amp;#39;2014-04-10&amp;#39;; なのでdateコラムにindexをつけた。このテーブルに5億ぐらいのレコードがあるとき、レスポンス時間はどのぐらいなのか検討したい。
環境： SSD: 256GB
テーブルに5億レコードを挿入する この記事は大変参考になりました：Mass inserting data in Rails without killing your performance
単純の(5*10**8).times { Model.create(options) }なら20日間がかかるのに対し、１つのINSERTを大量のデータをまとめ（bulk insertと呼ばれる）すると１０時間しかかからない。
最終のrakeタスクのコードは以下となる
# insert_data.rake namespace :insert_data do desc &amp;#34;Insert dummy activity records&amp;#34; task run: :environment do TOTAL_RECORDS = 500000000 RECORDS_PER_TIME = 50000 CONN = ActiveRecord::Base.connection start_time = Time.now (TOTAL_RECORDS/RECORDS_PER_TIME).times do |i| inserts = Array.</description></item><item><title>API開発用必要なGemのまとめ（2015/08更新）</title><link>http://example.org/post/gem-curation/</link><pubDate>Fri, 30 Jan 2015 04:50:00 +0000</pubDate><guid>http://example.org/post/gem-curation/</guid><description>初めてRailsプロジェクトに入ったとき、Gemfileを見ても全くわからなかった。Rails初心者のため必要なGemをまとめました。良いGemを発見したらどんどん更新していこうと思います。
2015/08/13時点
データベース関連 mysql2 MySQLアダプタ MySQLを使うなら必須 redis Ruby client library for Redis cache, session保存用 ar-octopus レプリケーション (master+slave管理) switch_point (※ 2015/08/13追加） ar-octopusの代替。機能はar-octopusまで高くないが、master+slave切り替えぐらいなら十分 paranoia 論理削除 API grape REST API生成 grape-entity grapeのサーポート レスポンス(json)を簡単に記述できる grape-swagger grapeのサーポート Swaggerドキュメントを生成する kramdown grape-swaggerのサーポート markdownパーサー rack-cors Cross-Origin Resource Sharing (CORS)をハンドリング Swaggerを別のサーバーに置く場合はこれが必須 kaminariまたはgrape-kaminari APIのページネーション テスト rspec-rails テストフレームワーク capybara (※ 2015/08/13追加） Websiteのテストフレームワーク shoulda-matchers (※ 2015/08/13追加） モデルテストに便利 spork-rails テストの実行時間を短縮してくれる factory_girl_rails テストデータを用意する database_cleaner FactoryGirlにて作成するテストデータを、テストを実行する度に消去する turnip (※ 2015/08/13追加） Rspecの中にCucumber風コードを書ける capybara-screenshot (※ 2015/08/13追加） Capybaraのテストが失敗したら自動的にスクリーンショートを撮る ユーザ認証 devise ユーザ登録・ログインまで全てやってくれる 管理画面 activeadmin 10分で作れる管理画面 Push通知 houston iOSデバイスにpush通知を送る定番のgem invalid tokenが混じると通知が届かないバグがある（2014/12) parse-ruby-client (※ 2015/08/13追加） Parseと連携 バックグラウンド処理 sidekiq バックグラウンドworkerの定番 sucker_punch (※ 2015/08/13追加） Sidekiqはredisが必須なのでインフラコストが上がる。メールをバックグラウンドで送るぐらいならsucker_punchの方が軽い whenever Cron jobs管理 画像関連 carrierwave 画像アップロードの定番 paperclip (※ 2015/08/13追加） これも画像アップロードの定番 fog carrierwaveのサーポート S3にアップロード rmagick 画像処理（サイズ調整、角丸など）に便利 デプロイ用 unicorn 本番用のWebサーバー 設定は面倒 capistrano 有名なデプロイツール capistrano-rails db migrateとassets compileタスクを用意する capistrano-rbenv デプロイ先にrbenv使ったらこれが必要 capistrano3-unicorn デプロイした後unicornを再起動してくれる Ubuntu14.</description></item><item><title>Docker経由Swagger UIを入れてみた</title><link>http://example.org/post/use-swagger-ui-in-docker/</link><pubDate>Tue, 20 Jan 2015 11:10:00 +0000</pubDate><guid>http://example.org/post/use-swagger-ui-in-docker/</guid><description>はじめに 目的：SwaggerUIを開発環境に入れて、Railsと組み合わせたい Railsのswagger-ui gemもありますが、あれはSwaggerUIが古い。最新版のSwaggerUIを使いたい。 手動で構築するのがちょっと面倒だから、Dockerを使って入れてみた
作業 Docker HubにSwagger UIを探してこういうイメージを見つけた
https://registry.hub.docker.com/u/capoferro/swagger-ui/
capoferro / swagger-ui Simple docker container to serve the Swagger UI
インストールする方法は以下となります
イーメジをpullする $ docker pull capoferro/swagger-ui コンテナを起動する $ docker run -d -p 4567:80 capoferro/swagger-ui このコマンドはSwaggerUIコンテナの80ポートをホストマシンの4567ポートに紐付ける
ブラウザにboot2dockerマシンのIP（普通192.168.59.103）のポート4567をアクセスするとSwaggerの画面が出てくる これでSwaggerUIのインストールが成功した。
最後にRailsのアプリを紐付けること:
動いているSwaggerコンテナのIDを確認する ( $ docker ps) 今回コンテナIDは859502ad6704がわかりました。
SwaggerUIコンテナに入る $ docker exec -i -t 8595 /bin/bash (8595はコンテナIDの先頭４文字です。コンテナIDを指定するとき先頭3,4文字でも動くはず）
index.htmlの中にurlのところにデフォルトURLをRailsのswagger_docパスに変更する： viでもいいですが、キーボードがおかしかったのでsedを使いました $ sed -i &amp;#34;s@http://petstore.</description></item><item><title>Docker + Figを使ってRailsの開発環境を構築する</title><link>http://example.org/post/docker-figwoshi-tuterailsnokai-fa-huan-jing-wogou-zhu-suru/</link><pubDate>Mon, 19 Jan 2015 12:38:00 +0000</pubDate><guid>http://example.org/post/docker-figwoshi-tuterailsnokai-fa-huan-jing-wogou-zhu-suru/</guid><description>前回はDockerで構築したアプリを使うのを述べました。今回は実際どうやってそのRailsアプリを構築するのかを紹介します。
構築したい環境 Ruby 2.2 Rails 4.2.0 MySQL Redis シナリオ 以上の条件でコンテナを３つ準備します。
web ： Railsアプリ。もちろんRubyが入ってるので今回はofficial ruby imageをベースにコンテナを作ります db ： official MySQL imageを採用します redis： official Redis imageを採用します 気づいたのは使った３つのofficial imagesは全部Debian (Ubuntuと似ているLinux OS）です。違うOSでも問題ないでしょう。
webコンテナのDockerfile
# Docker hubのruby imageをpullする。2.2.0を指定 FROM ruby:2.2.0 MAINTAINER vanhuyz # 必要なパッケージをインストール RUN apt-get update -qq &amp;amp;&amp;amp; apt-get install -y build-essential libpq-dev # myappディレクトリーをwebコンテナに作成 RUN mkdir /myapp # RUN, CMDのworking directoryを指定 WORKDIR /myapp # hostマシンのGemfileをwebコンテナにコピーする ADD Gemfile /myapp/Gemfile # webコンテナにbundle installを実行 RUN bundle install # 生成されたファイルをwebコンテナにコピーする ADD .</description></item><item><title>魔法のDockerを使ってみよう</title><link>http://example.org/post/try-magical-docker/</link><pubDate>Fri, 16 Jan 2015 08:37:00 +0000</pubDate><guid>http://example.org/post/try-magical-docker/</guid><description>前回はDockerをインストールするまで記述しました。今回は実際Dockerで構築したRailsアプリを動かしましょう。
前提 Mac OS Xにboot2dockerが起動された状態、またはLinuxにDockerインストール済み
作業 まずFigというコンテナ管理ツールをインストールします $ curl -L https://github.com/docker/fig/releases/download/1.0.1/fig-`uname -s`-`uname -m` &amp;gt; /usr/local/bin/fig; chmod +x /usr/local/bin/fig 次に構築したRailsアプリをcloneします $ git clone git@github.com:vanhuyz/rails-docker-test.git $ cd rails-docker-test 最後にfig up するだけで $ fig up 完了!
構築したRailsアプリの確認　（Yosemite編） 僕のRails環境は以下のように構成されています
Ruby 2.2 Rails 4.2.0 MySQL Redis では構築できた環境を確認しましょう！
まずboot2docker仮想マシンのIPを確認します。
Vans-MacBook-Air:~ vanhuy$ boot2docker ip 192.168.59.103 webコンテナは3000ポートに紐付いているのでブラウザから192.168.59.103:3000にアクスセスしてみると
やった！ちゃんとRailsの初期画面が出ています。
次にmysqlの確認：
Vans-MacBook-Air:~ vanhuy$ mysql -h 192.168.59.103 -u root -p Enter password: Welcome to the MySQL monitor.</description></item><item><title>Dockerをインストールする（Yosemite編）</title><link>http://example.org/post/install-docker-on-yosemite/</link><pubDate>Thu, 15 Jan 2015 07:59:00 +0000</pubDate><guid>http://example.org/post/install-docker-on-yosemite/</guid><description>Docker導入する理由 開発環境を一気構築できる コンテナ型仮想化なので軽い Vagrant/Chefより学習コストが低い 小さいコンテナから構成されるので安定性が高まる Amazon EC2 Container Serviceが発表されたから本番構築でも可能に！ Yosemiteにインストールしてみよう インストール方法は非常に簡単です。
Boot2dockerパッケージをダウンロードする ダウンロードしたパッケージをダブルクリックしてインストールする Boot2Dockerアプリを起動する どのターミナルにも使いたい場合は以下のコマンドを~/.bash_profileに追加する $(boot2docker shellinit) 終わり！ 参考：公式サイト
Boot2dockerを分解してみよう ではBoot2dockerは何が入っているのかを調べてみた。
VirtualBox：仮装化ソフトウェア Boot2Docker：小さいLinuxベースOS。DockerはLinuxベースで動作するから、Macに動作する場合は仮装マシンが必要。インストールできたらboot2docker-vmがVirtualBoxに入っているはず Boot2Docker Management Tool： Boot2Dockerの管理ツール。コマンドが充実。 $ boot2docker Usage: boot2docker [&amp;lt;options&amp;gt;] {help|init|up|ssh|save|down|poweroff|reset|restart|config|status|info|ip|shellinit|delete|download|upgrade|version} [&amp;lt;args&amp;gt;] $ boot2docker ssh # boot2docker仮装マシンにSSHする $ cat /proc/version Linux version 3.16.7-tinycore64 (root@064f0e1ce709) (gcc version 4.7.2 (Debian 4.7.2-5) ) #1 SMP Tue Dec 16 23:03:39 UTC 2014 Docker Client：dockerコマンドが使えるようになります。Dockerの使い方は本当に長くなりそうですから、以下は重要なコマンドをリストアップします $ docker # 全部コマンドが見られる $ docker version # dockerバージョンを見る $ docker search &amp;lt;string&amp;gt; # DockerHubにイメージを検索 $ docker pull &amp;lt;username&amp;gt;/&amp;lt;repository&amp;gt; # イメージをダウンロード $ docker run &amp;lt;username&amp;gt;/&amp;lt;repository&amp;gt; &amp;lt;command&amp;gt; ## コンテナの中にコマンドを実行する。例えば： $docker run learn/tutorial echo “hello” $ docker ps -l # 作ったコンテナのIDを調べる $ docker commit &amp;lt;ID&amp;gt; &amp;lt;username&amp;gt;/&amp;lt;new_repository&amp;gt; ## コンテナをイメージ化する $ docker inspect &amp;lt;ID&amp;gt; # コンテナの全部情報が見られる $ docker images # 現在のホストになんのイメージが入っているのか $ docker push &amp;lt;username&amp;gt;/&amp;lt;repository&amp;gt; # DockerHubにpushする 参考：Try Docker</description></item></channel></rss>